/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. All user-specific
 * data, such as conversations and messages, is nested within a private user data tree,
 * ensuring users can only access their own information. A dedicated top-level collection
 * is used to enforce username uniqueness at sign-up without exposing user data.
 *
 * Data Structure:
 * - /usernames/{username}: A lookup collection to ensure unique usernames.
 * - /users/{userId}: The root for all private user data.
 * - /users/{userId}/conversations/{conversationId}: User's private conversations.
 * - /users/{userId}/conversations/{conversationId}/messages/{messageId}: Messages within a conversation.
 *
 * Key Security Decisions:
 * - User Isolation: All data under /users/{userId} is strictly accessible only to the
 *   authenticated user matching that userId. There is no concept of shared or public data.
 * - Username Uniqueness: The /usernames collection allows for a "create-once" operation
 *   to claim a username but explicitly disallows reading or listing to prevent user enumeration attacks.
 * - No User Listing: It is not possible to list all users in the /users collection.
 *   Users can only fetch their own profile document directly.
 * - Default Deny: Access is implicitly denied unless an explicit `allow` rule grants it.
 *
 * Denormalization for Authorization:
 * The hierarchical path structure (/users/{userId}/...) is the primary mechanism for
 * authorization, avoiding the need for costly `get()` calls in subcollection rules.
 * For relational integrity, documents like Conversations contain a `userId` field that
 * must match the path on creation and is immutable thereafter.
 *
 * Structural Segregation:
 * The /usernames collection is segregated from the /users collection. This separates the
 * public-facing concern of username validation from the private concern of storing user profile
 * data, leading to simpler and more secure rules for each.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------------------------------------------
    // Helper Functions
    // --------------------------------------------------------------------

    // Returns true if the user is authenticated.
    function isSignedIn() {
      return request.auth != null;
    }

    // Checks if the currently signed-in user's ID matches the provided userId.
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Checks for ownership on an existing document. Used for update/delete operations.
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // --------------------------------------------------------------------
    // Collection Rules
    // --------------------------------------------------------------------

    /**
     * @description Enforces username uniqueness. Allows a user to claim a unique username
     *   during sign-up but prevents enumeration, modification, or deletion.
     * @path /usernames/{username}
     * @allow A new user (auth.uid: 'user_xyz') tries to claim a username (create):
     *   `create /usernames/new_user_name {'id': 'user_xyz'}`
     * @deny An anonymous or authenticated user tries to read the collection (list):
     *   `list /usernames`
     * @deny An existing user tries to change who owns a username (update):
     *   `update /usernames/some_user_name`
     * @principle Prevents data leakage by disallowing reads, while enabling a core sign-up feature.
     *   Validates relational integrity by ensuring the internal user ID matches the creator.
     */
    match /usernames/{username} {
      allow get: if false;
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages user profile documents. A user can create their own profile,
     *   and only they can ever read, update, or delete it.
     * @path /users/{userId}
     * @allow The owner (auth.uid: 'user_abc') reads their own profile (get):
     *   `get /users/user_abc`
     * @deny A different user (auth.uid: 'user_xyz') tries to read another's profile (get):
     *   `get /users/user_abc`
     * @deny The public cannot list all users in the system (list):
     *   `list /users`
     * @principle Restricts access to a user's own data tree, a foundational security practice.
     *   Enforces data consistency between the document ID and its internal 'id' field.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);

      /**
       * @description Secures a user's conversations. Only the owner of the user profile
       *   can create, read, update, or delete their own conversations.
       * @path /users/{userId}/conversations/{conversationId}
       * @allow The owner (auth.uid: 'user_abc') lists their own conversations (list):
       *   `list /users/user_abc/conversations`
       * @deny A different user (auth.uid: 'user_xyz') tries to read a conversation (get):
       *   `get /users/user_abc/conversations/convo_123`
       * @principle Enforces document ownership for all operations within a user's private subcollection.
       *   Validates that new conversations correctly reference their parent user.
       */
      match /conversations/{conversationId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);

        /**
         * @description Secures messages within a conversation. Inherits ownership from the
         *   parent user document, ensuring only that user can manage their messages.
         * @path /users/{userId}/conversations/{conversationId}/messages/{messageId}
         * @allow The owner (auth.uid: 'user_abc') creates a new message (create):
         *   `create /users/user_abc/conversations/convo_123/messages/msg_456 {...}`
         * @deny A different user (auth.uid: 'user_xyz') tries to delete a message (delete):
         *   `delete /users/user_abc/conversations/convo_123/messages/msg_456`
         * @principle Extends path-based ownership to deeply nested subcollections, maintaining
         *   security throughout the user's data tree.
         */
        match /messages/{messageId} {
          allow get: if isOwner(userId);
          allow list: if isOwner(userId);
          allow create: if isOwner(userId) && request.resource.data.conversationId == conversationId;
          allow update: if isExistingOwner(userId) && request.resource.data.conversationId == resource.data.conversationId;
          allow delete: if isExistingOwner(userId);
        }
      }
    }
  }
}